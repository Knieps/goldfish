---
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Goldfish Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: literature_goldfish_vignette.bib

---

# Introduction

\label{sec:intro}

Social networks change through time, and researchers from various disciplines have an interest in understanding the social mechanisms that drive these dynamics. Often, the data available have the form of relational events where dynamic observations do not stem from consecutively collecting social networks into a panel, but but by observing fine-grained time-stamped interactions between two nodes that may or may not be directly related to social network ties. Examples are automatically collected network data from communication studies or social media studies, social science studies employing social sensors, or archival network studies with detailed information about times of relational actions between two nodes.

Two major conceptual approaches co-exist in statistical network analysis. One approach conveives of the dyad as the unit analyis. The probability of a tie thus depends on its embedding in structures within the social space. The most prominent statistical model develops this idea is 

. The other approach conceives of ties as controlled by actors that create or propose ties

These two approaches have also been put forward to studying time-stamped network data. The Relational Event Model by \citet{Butts2008} is essentially in the tradition of tie-oriented models. Relational events




# Dynamic Network Actor Models (DyNAMs)
\label{sec:models}

The actor-oriented models that the goldfish package implements has been called Dynamic Network Actor Models (DyNAMs). Is builds upon ...
Alternative actor-oriented event models have been proposed, e.g.

## DyNAMs for directed relational events
 [@Stadtfeld2017b]

## DyNAMs for coordination ties
 [@Stadtfeld2017]

## Comparing DyNAMs to the Relational Event Model (REM)

# Getting started
## Step 0: Load the goldfish package and the data
Loading the goldfish package:
 
```{r eval = F}

library(goldfish)
 
```

Loading the data:
 
```{r }

data("Social_Evolution")

```
 


### An initial look at the data:
 
```{r }
 
#head(calls)
 
```

 
```{r echo=FALSE, fig.width = 7, fig.height = 7}

 
#hist(calls$time, breaks = 100)
 
```
 


## Step  1: Create Goldfish objects

### Define the nodeset

The nodeset can be created using the following function:

```{r eval = F}

actors <- defineNodes(nodes = actors)  


```


The `defineNodes` function processes and checks the data.frame passed to `nodes` argument.
The `nodes` argument requires a data.frame with information about the nodes that are present throughout the time window of interest. This data.frame must contain at least one vector, which is of the same length as the number of nodes. Other than that it can contain information about the nodes -`label` (e.g., Actor 1), whether the node is `present` at the start of the data collection as well as the the initial (at T0), or non-changing values for node attributes. For instance, this data.frame could look like this:


```{r echo = F}

actors <- data.frame(label = paste0("Actor ", c(1:4,7)), present = T, gender = sample.int(2, 5, replace = T))

head(actors)

```
Please note that `goldfish` uses the rownames of this data.frame as the internal node IDs. The `label` variable must be of character class.

If you have changing node-attributes you can link `changeEvents` data.frames to the nodeset in the following way: 

```{r eval = F}
actors <- linkEvents(x = actors, 
                    attribute = "present",
                    changeEvents = compositionChangeEvents)
```

The `linkEvents` function links events lists of changing attributes (e.g., present, gender) to the nodeset. The nodeset can be specified with the argument `x`, the attribute that is changed with the events list has to be defined in the `attribute` argument as a string. The `changeEvents` contains a data.frame that describes when and how the nodes attributes change. If no data is linked to an attribute, the attribute variables specified in the `nodes` arguments are assumed to stay constant (e.g., gender). 

Note that 'present', if given as a node attribute, must be true at a given time point for any node to be involved in an event. In the case of a friendship and phone call network with other dynamic actor attributes, someone losing their phone should not be specified as present = false, since then their friendships and individual attributes cannot change! A separate attribute and corresponding event list should be added in such situations that only one type of event cannot occur for a given actor.  

The `changeEvents` data.frames mentioned above must be in the following format:

```{r echo = F}
compositionChangeEvents <- data.frame(time = 3:4 + .5, node = 1, replace = c(F, T))

head(compositionChangeEvents)
```


Here the `time` column in numeric or POSIXct format indicates when the change happens. The `node` column must correspond with either the row number of the nodes data.frame or the label string. The column `replace` contains boolean values indicating whether the node is present at that time. For instance, the example above shows that node 1 joins the network at timepoint 4.5. 

Other types of node attribute changes (e.g., on which floor an actor lives) are specified with the same data.frame type:

```{r}

moveEvents <- data.frame(time = 7:8, node = 2, replace = c(3,5))

moveEvents
```

If the column indicating the change is called `replace`, goldfish expects values that replace the previous state of the node (e.g., actor 3 moves from floor 3 to floor 5: replace = 5). Alternatively, the increment can be specified (e.g., increment = 2). For this, the column must be named `increment`. 

### Define the independent networks

Networks that function as independent variables can be defined with the following function:

```{r eval = F}

friendshipNetwork <- defineNetwork(matrix = friend.w1, nodes = actors, directed = T)


```

Here the `matrix` (friend.w1) describes the initial state of the network at T0. This matrix must contain the same nodeset as defined with the `defineNodes` function and the order of the rows must correspond. The matrix must be binary*(?)* and can be directed or undirected (as specified with the directed argument). If no matrix is provided, `goldfish` assumes the initial state to be empty (i.e., a matrix containing only 0s). 

If this network is updated over time (e.g., a new wave of friendship data is collected), these changes can be added with the `linkEvents` function - similar to link changing attribute events to a nodeset. This time, the user needs to provide the network and the associated nodeset.

```{r eval = F}

friendshipNetwork <- linkEvents(x = friendshipNetwork,
                                nodes = actors,
                                changeEvents = friendshipChange)

```


The data.frame passed to the `changeEvents` argument must be in the following format

```{r }
friendshipChange <- data.frame(time = c(100, 103), 
                               sender = c("Actor 4", "Actor 3"),
                               receiver = c("Actor 7", "Actor 2"), replace = c(1,0))

friendshipChange
```

Alternatively to the `replace` column, a column called `increment` can be used, as we mentioned earlier. For friendship networks, 1 = tie creation, -1 = tie dissolution. The columns `sender` and `receiver` can be in the format numeric or character. For the numeric case, the entries must correspond to the rownumbers of the nodes data.frame. When character strings are used, they must correspond to the labels in the nodes data.frame. In the example shown above, Actor 4 nominates actor 7 as a friend at timepoint 100 and at timepoint 103 Actor 3 drops the tie to Actor 2.



### Global attributes

Imagine that you want to include a variable that is identical for each node but changes over time. For instance, seasonal climate changes. Such a changing global attribute can be defined with the `defineGlobalAttribute` function

```{r eval = F}
seasons <- defineGlobalAttribute(data.frame(time = 1:12, value = 1:12))
```


### Define the dependent event list

The event list that is intended to be modeled by goldfish is specified with the `defineDependentEvents` function:

```{r eval = F}
dependent.calls <- defineDependentEvents(events = calls, nodes = actors)

```

The nodes argument must be an object defined with the `defineNodes` function. The dependent events should be a data.frame containing the following columns:

```{r }
calls <- data.frame(time = 1:5, sender = c(1, 1:4), receiver = c(5:1))

calls
```

### Model specification

Now we move to our model specification. Here we first define our dependent network, in the example case this is the call network, then beyond the tilde we specify effects and the variables for which the effects are expected to occur. To see the possible effects, use the function `goldfishEffects`.
```{r eval = F}
formula <- calls ~  out(callNetwork) + recip(callNetwork) + recip(callNetwork, window = 3600) + 
  mixedRecip(callNetwork, distance, window = c(3600, NA)) +
  sameX(floor) + effXYZ(callNetwork, floor)
```


## Step  2: Estimation




## Step  3: Interpreting and diagnosing results

# Extending DyNAMs and REMs with own effects

# Conclusions

# References
